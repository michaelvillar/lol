// Generated by CoffeeScript 1.4.0
(function() {
  var City, Cluster, rand,
    _this = this,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };

  Cluster = require('cluster.coffee');

  rand = function(from, to) {
    return Math.round(Math.random() * (to - from) + from);
  };

  City = (function() {

    function City() {
      this.priceAt = __bind(this.priceAt, this);

      this.populationAt = __bind(this.populationAt, this);

      this.distribute = __bind(this.distribute, this);

      var cluster, row, x, y, _i, _j, _ref, _ref1;
      this.size = [100, 60];
      this.clusters = [];
      this.clustersGrid = [];
      for (x = _i = 0, _ref = this.size[0] - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; x = 0 <= _ref ? ++_i : --_i) {
        row = [];
        this.clustersGrid.push(row);
        for (y = _j = 0, _ref1 = this.size[1] - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; y = 0 <= _ref1 ? ++_j : --_j) {
          cluster = new Cluster([]);
          this.clusters.push(cluster);
          row.push(cluster);
        }
      }
      this.distribute();
    }

    City.prototype.distribute = function() {
      var addPeople, center, centerRef, centerRefIndex, centers, centersCount, cluster, highBound, i, lowBound, number, nx, ny, padding, x, y, _i, _len, _results,
        _this = this;
      this.population = 0;
      lowBound = 0.0075 * this.size[0] * this.size[1];
      highBound = 0.01 * this.size[0] * this.size[1];
      centersCount = 0.003 * this.size[0] * this.size[1];
      centers = [];
      padding = 0.0035 * this.size[0] * this.size[1];
      centers.push([Math.min(this.size[0] - 1, Math.max(0, rand(this.size[0] / 2 - padding, this.size[0] / 2 + padding))), Math.min(this.size[1] - 1, Math.max(0, rand(this.size[1] / 2 - padding, this.size[1] / 2 + padding)))]);
      while (centers.length < centersCount) {
        centerRefIndex = rand(0, centers.length - 1);
        centerRef = centers[centerRefIndex];
        centers.push([Math.min(this.size[0] - 1, Math.max(0, rand(centerRef[0] - padding, centerRef[0] + padding))), Math.min(this.size[1] - 1, Math.max(0, rand(centerRef[1] - padding, centerRef[1] + padding)))]);
      }
      addPeople = function(i, nx, ny) {
        var cluster, k, number;
        if (nx < 0 || nx >= _this.size[0]) {
          return;
        }
        if (ny < 0 || ny >= _this.size[1]) {
          return;
        }
        cluster = _this.clustersGrid[nx][ny];
        k = Math.max(0.01, 1 - (Math.abs(i) / 25));
        number = rand(lowBound * k, highBound * k);
        cluster.addPeople(number);
        return _this.population += number;
      };
      _results = [];
      for (_i = 0, _len = centers.length; _i < _len; _i++) {
        center = centers[_i];
        number = rand(lowBound, highBound);
        cluster = this.clustersGrid[center[0]][center[1]];
        cluster.addPeople(number);
        this.population += number;
        _results.push((function() {
          var _j, _k, _l, _len1, _ref, _results1;
          _results1 = [];
          for (i = _j = 1; _j <= 100; i = ++_j) {
            _ref = [-i, i];
            for (_k = 0, _len1 = _ref.length; _k < _len1; _k++) {
              x = _ref[_k];
              for (y = _l = -i; -i <= i ? _l <= i : _l >= i; y = -i <= i ? ++_l : --_l) {
                nx = center[0] + x;
                ny = center[1] + y;
                addPeople(Math.sqrt(x * x + y * y), nx, ny);
              }
            }
            _results1.push((function() {
              var _m, _ref1, _ref2, _results2;
              _results2 = [];
              for (x = _m = _ref1 = -i + 1, _ref2 = i - 1; _ref1 <= _ref2 ? _m <= _ref2 : _m >= _ref2; x = _ref1 <= _ref2 ? ++_m : --_m) {
                _results2.push((function() {
                  var _len2, _n, _ref3, _results3;
                  _ref3 = [-i, i];
                  _results3 = [];
                  for (_n = 0, _len2 = _ref3.length; _n < _len2; _n++) {
                    y = _ref3[_n];
                    nx = center[0] + x;
                    ny = center[1] + y;
                    _results3.push(addPeople(Math.sqrt(x * x + y * y), nx, ny));
                  }
                  return _results3;
                })());
              }
              return _results2;
            })());
          }
          return _results1;
        })());
      }
      return _results;
    };

    City.prototype.populationAt = function(_arg, radius) {
      var nx, ny, pop, x, y, _i, _j, _ref, _ref1, _ref2, _ref3;
      x = _arg[0], y = _arg[1];
      if (radius == null) {
        radius = 0;
      }
      pop = 0;
      for (nx = _i = _ref = x - radius, _ref1 = x + radius; _ref <= _ref1 ? _i <= _ref1 : _i >= _ref1; nx = _ref <= _ref1 ? ++_i : --_i) {
        for (ny = _j = _ref2 = y - radius, _ref3 = y + radius; _ref2 <= _ref3 ? _j <= _ref3 : _j >= _ref3; ny = _ref2 <= _ref3 ? ++_j : --_j) {
          if (nx < 0 || nx >= this.size[0]) {
            continue;
          }
          if (ny < 0 || ny >= this.size[1]) {
            continue;
          }
          if (Math.sqrt((nx - x) * (nx - x) + (ny - y) * (ny - y)) > radius) {
            continue;
          }
          pop += this.clustersGrid[nx][ny].population();
        }
      }
      return pop;
    };

    City.prototype.priceAt = function(_arg) {
      var x, y;
      x = _arg[0], y = _arg[1];
      return this.clustersGrid[x][y].price();
    };

    return City;

  })();

  module.exports = City;

}).call(this);
